
"""Tests for the pyam_helpers module."""
# Tests partially generated by CodiumAI
import unittest

import pyam
import pandas as pd

from iamcompact_vetting.pyam_helpers import (
    make_consistent_units,
    as_pandas_series,
)


class TestMakeConsistentUnits(unittest.TestCase):
    """Tests for the make_consistent_units function."""

    # The function is called with two IamDataFrame objects that have different
    # units for some variables.
    def test_make_consistent_units_with_different_units(self):
        # Create two IamDataFrame objects with different units for some
        # variables
        df_data = pd.Series(
            [1.0] * 3*4, index=pd.MultiIndex.from_tuples(
                [
                    ('model_a', 'scenario_a', 'region_a', _var, _unit,
                     2020 + 5*i)
                    for _var, _unit in [
                        ('Primary Energy', 'TWh/yr'),
                        ('Emissions|CO2', 'Mt CO2'),
                        ('Emissions|CH4', 'Mt CH4'),
                        ('Secondary Energy|Electricity', 'TWh/yr'),
                    ]
                    for i in range(3)
                ],
                names=['model', 'scenario', 'region', 'variable', 'unit',
                       'year']
            )
        )
        match_df_data = pd.Series(
            [2.5] * 3*3, index=pd.MultiIndex.from_tuples(
                [
                    ('model_a', 'scenario_a', 'region_a', _var, _unit,
                     2025 + 5*i)
                    for _var, _unit in [
                        ('Emissions|CO2', 'Mt CO2'),
                        ('Primary Energy', 'EJ/yr'),
                        ('Emissions|CH4', 'kt CH4'),
                    ]
                    for i in range(3)
                ],
                names=['model', 'scenario', 'region', 'variable', 'unit',
                       'year']
            )
        )
        expected_result = pd.Series(
            [3.6/1000]*3 + [1.0]*3 + [1000.0]*3 + [1.0]*3,
            index=pd.MultiIndex.from_tuples(
                [
                    ('model_a', 'scenario_a', 'region_a', _var, _unit,
                     2020 + 5*i)
                    for _var, _unit in [
                        ('Primary Energy', 'EJ/yr'),
                        ('Emissions|CO2', 'Mt CO2'),
                        ('Emissions|CH4', 'kt CH4'),
                        ('Secondary Energy|Electricity', 'TWh/yr'),
                    ]
                    for i in range(3)
                ],
                names=['model', 'scenario', 'region', 'variable', 'unit',
                       'year']
            )
        )
        df = pyam.IamDataFrame(data=df_data)
        match_df = pyam.IamDataFrame(data=match_df_data)
        expected_df = pyam.IamDataFrame(data=expected_result)

        # Call the function under test
        result = make_consistent_units(df=df, match_df=match_df)

        # Assert that the result is an instance of IamDataFrame
        self.assertIsInstance(result, pyam.IamDataFrame)

        # Assert that the result has the same variables as df_data
        self.assertEqual(set(result.variable), set(df.variable))

        # Assert that the units of the variables in the result match the units
        # in match_df
        for _var in result.variable:
            if _var in match_df.variable:
                self.assertEqual(result.unit_mapping[_var],
                                 match_df.unit_mapping[_var])

        # Assert that the values in the result are the same as expected
        for variable in result.variable:
            self.assertTrue(result.equals(expected_df))
    ###END def TestMakeConsistentUnits.test_make_consistent_units_with_different_units

###END class TestMakeConsistentUnits


class TestAsPandasSeries(unittest.TestCase):
    """Tests for the as_pandas_series function."""

    # Returns a Series with the same data as the input IamDataFrame.
    def test_as_pandas_series(self):
        # Create a valid IamDataFrame
        expected_values = pd.Series(
            data=[1, 2],
            index=pd.MultiIndex.from_tuples(
                [
                    ('model1', 'scenario1', 'region1', 'variable1', 'unit1', 2020),
                    ('model2', 'scenario2', 'region2', 'variable2', 'unit2', 2030)
                ],
                names=['model', 'scenario', 'region', 'variable', 'unit', 'year']
            ),
        )
        df = pyam.IamDataFrame(expected_values)

        # Call the function under test
        result = as_pandas_series(df)

        # Check if the result is a pandas Series
        self.assertIsInstance(result, pd.Series)

        # Check if the result has a MultiIndex
        self.assertIsInstance(result.index, pd.MultiIndex)

        # Check if the result has the expected values
        pd.testing.assert_series_equal(result, expected_values)
    ###END def TestAsPandasSeries.test_as_pandas_series

    # Returns an empty Series when given an empty IamDataFrame.
    def test_empty_IamDataFrame(self):
        # Create an empty IamDataFrame
        df = pyam.IamDataFrame(
            pd.Series(
                data=[],
                index=pd.MultiIndex.from_tuples(
                    [],
                    names=['model', 'scenario', 'region', 'variable', 'unit', 'year']
                )
            )
        )
    
        # Call the function under test
        result = as_pandas_series(df)
    
        # Check if the result is an empty Series
        self.assertTrue(result.empty)
    ###END def TestAsPandasSeries.test_empty_IamDataFrame

###END class TestAsPandasSeries