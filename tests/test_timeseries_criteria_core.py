"""Tests for the timeseries_criteria_core module."""
# Partially Generated by CodiumAI

import unittest
import unittest.mock
import typing as tp

import pandas as pd
import numpy as np
import pyam

from iamcompact_vetting.iam.timeseries_criteria_core import (
    pyam_series_comparison,
    AggFuncTuple,
    TimeseriesRefCriterion,
)
from iamcompact_vetting.iam.dims import UnknownDimensionNameError
from iamcompact_vetting.pdhelpers import replace_level_values

from . import get_test_energy_iamdf_tuple as construct_test_iamdf



class TestPyamSeriesComparison(unittest.TestCase):
    """Tests for the pyam_series_comparison decorator."""

    # Converts units of iamdf1 to match iamdf2 when match_units is True
    def test_converts_units_when_match_units_is_true(self):
        @pyam_series_comparison(match_units=True)
        def custom_comparison(series1: pd.Series, series2: pd.Series) -> pd.Series:
            return series1 + series2

        with unittest.mock.patch(
                'iamcompact_vetting.pyam_helpers.make_consistent_units'
        ) as mock_make_consistent_units:
            mock_make_consistent_units.side_effect = lambda df, match_df: df

            iamdf1 = pyam.IamDataFrame(
                pd.DataFrame(
                    {
                        'model': ['model1']*3,
                        'scenario': ['scenario1']*3,
                        'region': ['World']*3,
                        'variable': ['variable1']*3,
                        'unit': ['unit1']*3,
                        'year': [2020, 2025, 2030],
                        'value': [1, 2, 3]
                    }
                )
            )
            iamdf2 = pyam.IamDataFrame(
                pd.DataFrame(
                    {
                        'model': ['model1']*3,
                        'scenario': ['scenario1']*3,
                        'region': ['World']*3,
                        'variable': ['variable1']*3,
                        'unit': ['unit2']*3,
                        'year': [2020, 2025, 2030],
                        'value': [4, 5, 6]
                    }
                )
            )

            result = custom_comparison(iamdf1, iamdf2)

            mock_make_consistent_units.assert_called_once_with(df=iamdf1, match_df=iamdf2)
    ###END def TestPyamSeriesComparison.test_converts_units_when_match_units_is_true

    # Gives correct result for two IamDataFrames with the same variables but
    # different units for one of the variables, when being passed a simple
    # subtraction function, and match_units is True
    def test_correct_result_for_two_iamdfs_with_same_variables_diff_units_and_values(
            self
    ):
        @pyam_series_comparison(match_units=True)
        def custom_comparison(series1: pd.Series, series2: pd.Series) -> pd.Series:
            return series1 - series2

        iamdf1 = pyam.IamDataFrame(
            pd.DataFrame(
                {
                    'model': ['model1']*6,
                    'scenario': ['scenario1']*6,
                    'region': ['World']*6,
                    'variable': ['Primary Energy|Wind']*3 + ['Emissions|CO2']*3,
                    'unit': ['TWh']*3 + ['Mt CO2/yr']*3,
                    'year': [2020, 2025, 2030]*2,
                    'value': [1000.0, 2000.0, 2500.0, 1100.0, 1500.0, 1700.0]
                }
            )
        )
        iamdf2 = pyam.IamDataFrame(
            pd.DataFrame(
                {
                    'model': ['model1']*6,
                    'scenario': ['scenario1']*6,
                    'region': ['World']*6,
                    'variable': ['Primary Energy|Wind']*3 + ['Emissions|CO2']*3,
                    'unit': ['EJ']*3 + ['Mt CO2/yr']*3,
                    'year': [2020, 2025, 2030]*2,
                    'value': [4.0, 5.0, 6.0, 1300.0, 1400.0, 1450.0]
                }
            )
        )

        expected_result = pyam.IamDataFrame(
            pd.DataFrame(
                {
                    'model': ['model1']*6,
                    'scenario': ['scenario1']*6,
                    'region': ['World']*6,
                    'variable': ['Primary Energy|Wind']*3 + ['Emissions|CO2']*3,
                    'unit': ['EJ']*3 + ['Mt CO2/yr']*3,
                    'year': [2020, 2025, 2030]*2,
                    'value': [1.0*3.6-4.0, 2.0*3.6-5.0, 2.5*3.6-6.0,
                              1100.0-1300.0, 1500.0-1400.0, 1700.0-1450.0]
                }
            )
        )

        result = custom_comparison(iamdf1, iamdf2)

        self.assertTrue(pyam.IamDataFrame(result).equals(expected_result))
    ###END def TestPyamSeriesComparison.test_correct_result_for_two_iamdfs_with_same_variables_diff_units_and_values

    # Gives correct result for two IamDataFrames with the same variables but
    # different units for one of the variables, and misaligned years. We then
    # expect the result to be as before for the matching years, and NaN for the
    # non-matching years, when being passed a simple addition function, and
    # match_units is True
    def test_correct_result_for_two_iamdfs_with_same_variables_diff_units_and_values_misaligned_years(
            self
    ):
        @pyam_series_comparison(match_units=True)
        def custom_comparison(series1: pd.Series, series2: pd.Series) -> pd.Series:
            return series1 - series2

        iamdf1 = pyam.IamDataFrame(
            pd.DataFrame(
                {
                    'model': ['model1']*6,
                    'scenario': ['scenario1']*6,
                    'region': ['World']*6,
                    'variable': ['Primary Energy|Wind']*3 + ['Emissions|CO2']*3,
                    'unit': ['TWh']*3 + ['Mt CO2/yr']*3,
                    'year': [2025, 2030, 2035]*2,
                    'value': [1000.0, 2000.0, 2500.0, 1100.0, 1500.0, 1700.0]
                }
            )
        )
        iamdf2 = pyam.IamDataFrame(
            pd.DataFrame(
                {
                    'model': ['model1']*6,
                    'scenario': ['scenario1']*6,
                    'region': ['World']*6,
                    'variable': ['Primary Energy|Wind']*3 + ['Emissions|CO2']*3,
                    'unit': ['EJ']*3 + ['Mt CO2/yr']*3,
                    'year': [2020, 2025, 2030]*2,
                    'value': [4.0, 5.0, 6.0, 1300.0, 1400.0, 1450.0]
                }
            )
        )

        expected_result = pyam.IamDataFrame(
            pd.DataFrame(
                {
                    'model': ['model1']*8,
                    'scenario': ['scenario1']*8,
                    'region': ['World']*8,
                    'variable': ['Primary Energy|Wind']*4 + ['Emissions|CO2']*4,
                    'unit': ['EJ']*4 + ['Mt CO2/yr']*4,
                    'year': [2020, 2025, 2030, 2035]*2,
                    'value': [pd.NA, 1.0*3.6-5.0, 2.0*3.6-6.0, pd.NA,
                              pd.NA, 1100.0-1400.0, 1500.0-1450.0, pd.NA]
                }
            )
        )

        result = custom_comparison(iamdf1, iamdf2)

        self.assertTrue(pyam.IamDataFrame(result).equals(expected_result))
###END class TestPyamSeriesComparison



class TestAggFuncTuple(unittest.TestCase):

    # Creating an instance with a valid callable function passed as a positional parameter
    def test_create_instance_with_valid_callable(self):
        def sample_agg_func(series: pd.Series) -> float:
            return series.sum()

        agg_func_tuple = AggFuncTuple(sample_agg_func)
        self.assertEqual(agg_func_tuple.func, sample_agg_func)
        self.assertEqual(agg_func_tuple.args, ())
        self.assertEqual(agg_func_tuple.kwargs, {})

    # Creating an instance with an invalid string method name
    def test_create_instance_with_invalid_string_method(self):
        with self.assertRaises(AttributeError):
            AggFuncTuple(func="non_existent_method")

    # Creating an instance with a valid string method name of SeriesGroupBy
    def test_create_instance_with_valid_string_method(self):
        valid_method_name = 'sum'
        agg_func_tuple = AggFuncTuple(valid_method_name)
        self.assertEqual(agg_func_tuple.func, valid_method_name)
        self.assertEqual(agg_func_tuple.args, ())
        self.assertEqual(agg_func_tuple.kwargs, {})

    # Iterating over the instance using __iter__
    def test_iterating_over_instance(self):
        # Create an instance of AggFuncTuple
        func = lambda x: x**2
        agg_func_tuple = AggFuncTuple(func, [1, 2, 3], {'power': 2})
    
        # Test iterating over the instance
        expected_values = (func, [1, 2, 3], {'power': 2})
        self.assertEqual(tuple(agg_func_tuple), expected_values)

    # Testing the comparison of 'agg_func_tuple.func' with the actual method reference
    def test_agg_func_tuple_kwargs(self):
        default_kwargs = {'param1': 100, 'param2': 'test'}
        agg_func_tuple = AggFuncTuple('mean', kwargs=default_kwargs)
        self.assertEqual(agg_func_tuple.func, 'mean')
        self.assertEqual(agg_func_tuple.args, tuple())
        self.assertEqual(agg_func_tuple.kwargs, default_kwargs)

    # Creating an instance with a non-callable func
    def test_create_instance_with_non_callable_func(self):
        with self.assertRaises(TypeError):
            AggFuncTuple(43.5)  # pyright: ignore[reportArgumentType]
        with self.assertRaises(TypeError):
            AggFuncTuple('__dict__')

    # Accessing fields using __getitem__ with string key
    def test_access_field_with_string_key(self):
        # Setup
        agg_func_tuple = AggFuncTuple('sum', [1, 2, 3], {'axis': 1})
    
        # Assertion
        self.assertEqual(agg_func_tuple['func'], 'sum')
        self.assertEqual(agg_func_tuple['args'], [1, 2, 3])
        self.assertEqual(agg_func_tuple['kwargs'], {'axis': 1})

    # Accessing fields using __getitem__ with integer index
    def test_accessing_fields_with_integer_index(self):
        # Setup
        agg_func = lambda x: x**2
        args = [1, 2, 3]
        kwargs = {'threshold': 10}
        agg_func_tuple = AggFuncTuple(agg_func, args, kwargs)
    
        # Assertion
        self.assertEqual(agg_func_tuple[0], agg_func)
        self.assertEqual(agg_func_tuple[1], args)
        self.assertEqual(agg_func_tuple[2], kwargs)

    # Correct mapping is generated when prefixing with **
    def test_correct_mapping_with_prefix(self):
        # Create an instance of AggFuncTuple with a valid callable function
        agg_func_tuple = AggFuncTuple('sum', args=(1, 2), kwargs={'key': 'value'})

        expected_mapping = dict(func='sum', args=(1, 2), kwargs={'key': 'value'})
    
        # Check if the mapping is correct
        self.assertEqual(dict(**agg_func_tuple), expected_mapping)

###END class TestAggFuncTuple


class TestTimeseriesRefCriterionBasic(unittest.TestCase):
    """Basic tests of the TimeseriesRefCriterion class, before comparisons."""
    # Initializing TimeseriesRefCriterion with valid parameters should create an instance correctly
    def test_initialization_with_valid_parameters(self):
        reference = pyam.IamDataFrame(data=pd.DataFrame({
            'model': ['model_a'],
            'scenario': ['scenario_a'],
            'region': ['region_a'],
            'variable': ['variable_a'],
            'unit': ['unit_a'],
            'year': [2020],
            'value': [1.0]
        }))
        comparison_function = lambda df1, df2: pd.Series([1.0])
        region_agg = 'sum'
        time_agg = 'mean'
        criterion = TimeseriesRefCriterion(
            criterion_name='test_criterion',
            reference=reference,
            comparison_function=comparison_function,
            region_agg=region_agg,
            time_agg=time_agg
        )
        self.assertIsInstance(criterion, TimeseriesRefCriterion)
        self.assertEqual(criterion.criterion_name, 'test_criterion')
        self.assertEqual(criterion.reference, reference)
        self.assertEqual(criterion.comparison_function, comparison_function)
        self.assertEqual(criterion._region_agg.func, 'sum')
        self.assertEqual(criterion._time_agg.func, 'mean')
    ###END def TestTimeseriesRefCriterion.test_initialization_with_valid_parameters

    # Initializing TimeseriesRefCriterion with invalid agg_func types should raise a TypeError
    def test_initialization_with_invalid_agg_func(self):
        reference = pyam.IamDataFrame(data=pd.DataFrame({
            'model': ['model_a'],
            'scenario': ['scenario_a'],
            'region': ['region_a'],
            'variable': ['variable_a'],
            'unit': ['unit_a'],
            'year': [2020],
            'value': [1.0]
        }))
        comparison_function = lambda df1, df2: pd.Series([1.0])
        invalid_agg_func = 123  # Invalid type for agg_func

        with self.assertRaises(TypeError):
            TimeseriesRefCriterion(
                criterion_name='test_criterion',
                reference=reference,
                comparison_function=comparison_function,
                region_agg=invalid_agg_func,  # pyright: ignore[reportArgumentType]
                time_agg='mean'
            )
    ###END def TestTimeseriesRefCriterion.test_initialization_with_invalid_agg_func

    # Method should raise a ValueError if broadcast_dims are missing in IamDataFrame
    def test_broadcast_dims_missing_in_iamdataframe(self):
        # Prepare
        criterion_name = 'test_criterion'
        reference = pyam.IamDataFrame(data=pd.DataFrame({
            'model': ['model_a'],
            'scenario': ['scenario_a'],
            'region': ['region_a'],
            'variable': ['variable_a'],
            'unit': ['unit_a'],
            'year': [2020],
            'value': [1.0],
        }))
        comparison_function = lambda df1, df2: pd.Series([1.0])
        region_agg = 'sum'
        time_agg = 'mean'
        broadcast_dims = ['model', 'scenario', 'missing_dim']  # Missing 'year'
        with self.assertRaises(UnknownDimensionNameError):
            TimeseriesRefCriterion(
                criterion_name=criterion_name,
                reference=reference,
                comparison_function=comparison_function,
                region_agg=region_agg,
                time_agg=time_agg,
                broadcast_dims=broadcast_dims
            )
    ###END def TestTimeseriesRefCriterion.test_broadcast_dims_missing_in_iamdataframe

    # _aggregate_time method should correctly aggregate a pd.Series over time
    def test_aggregate_time_method_correctly_aggregates_series(self):
        # Prepare
        from statistics import mean
        criterion_name = 'test_criterion'
        values_a: list[float] = [1.5, 3.7, 17.93, 7.1, 13.2]
        values_b: list[float] = [109.17, 147.47, 99.7, 199.9, 213.0]
        assert len(values_a) == len(values_b)
        time_length: int = len(values_a)
        regions_num: int = 2
        data_length: int = time_length*regions_num
        reference_and_data = pyam.IamDataFrame(data=pd.DataFrame({
            'model': ['model_a']*data_length,
            'scenario': ['scenario_a']*data_length,
            'region': ['region_a']*time_length + ['region_b']*time_length,
            'variable': ['variable_a']*data_length,
            'unit': ['unit_a']*data_length,
            'year': list(range(2020, 2020+time_length))*regions_num,
            'value': values_a + values_b,
        }))
        comparison_function = lambda df1, df2: pd.Series([1.0])
        region_agg = 'sum'
        time_agg = 'mean'
        criterion = TimeseriesRefCriterion(
            criterion_name=criterion_name,
            reference=reference_and_data,
            comparison_function=comparison_function,
            region_agg=region_agg,
            time_agg=time_agg
        )

        # Execute
        time_aggregated_series = \
            criterion._aggregate_time(reference_and_data._data)

        # Assert correct type
        self.assertIsInstance(time_aggregated_series, pd.Series)

        # Assert correct aggregations
        time_mean_series = pd.DataFrame(
            {
                'model': ['model_a']*regions_num,
                'scenario': ['scenario_a']*regions_num,
                'region': ['region_a', 'region_b'],
                'variable': ['variable_a']*regions_num,
                'unit': ['unit_a']*regions_num,
                'value': [mean(values_a), mean(values_b)]
            }
        ).set_index(['model', 'scenario',
                     'region', 'variable', 'unit'])['value']

        self.assertTrue(time_aggregated_series.equals(time_mean_series))

        region_aggregated_series = \
            criterion._aggregate_region(reference_and_data._data)

        self.assertIsInstance(region_aggregated_series, pd.Series)

        region_sum_series = pd.DataFrame(
            {
                'model': ['model_a']*time_length,
                'scenario': ['scenario_a']*time_length,
                'variable': ['variable_a']*time_length,
                'unit': ['unit_a']*time_length,
                'year': list(range(2020, 2020+time_length)),
                'value': [_val_a + _val_b
                          for _val_a, _val_b in zip(values_a, values_b)]
            }
        ).set_index(['model', 'scenario', 'variable', 'unit', 'year'])['value']

        self.assertTrue(region_aggregated_series.equals(region_sum_series))

    ###END def TestTimeseriesRefCriterion.test_aggregate_time_method

###END class TestTimeseriesRefCriterion


class TestTimeseriesRefCriterionComparisons(unittest.TestCase):
    """Test diff and ratio comparisons for the TimeseriesRefCriterion class."""

    refdata_df: pyam.IamDataFrame
    vettingdata_df: pyam.IamDataFrame
    diff_df: pyam.IamDataFrame
    ratio_df: pyam.IamDataFrame

    vettingdata_df, refdata_df, diff_df, ratio_df = construct_test_iamdf()

    _idf: pyam.IamDataFrame
    vettingdata_df_allEJ, diff_df_allEJ, ratio_df_allEJ = (
        _idf.convert_unit('TWh/yr', to='EJ/yr')
        for _idf in (vettingdata_df, diff_df, ratio_df)
    )

    @staticmethod
    @pyam_series_comparison
    def diff_compare(
        _refdata: pd.Series,
        _vettingdata: pd.Series,
    ) -> pd.Series:
        return _vettingdata - _refdata
    ###END def TestTimeseriesRefCriterionComparisons.diff_compare

    @staticmethod
    @pyam_series_comparison
    def ratio_compare(
        _refdata: pd.Series,
        _vettingdata: pd.Series,
    ) -> pd.Series:
        ratio_series: pd.Series = _vettingdata / _refdata
        return replace_level_values(
            ratio_series,
            mapping={_unit: ''
                     for _unit in ratio_series.index.get_level_values('unit')},
            level_name='unit'
        )
    ###END def TestTimeseriesRefCriterionComparisons.ratio_compare

    @classmethod
    def setUpClass(cls):
        cls.diff_criterion_mixed_units = TimeseriesRefCriterion(
            criterion_name='test_diff_criterion_mixed_units',
            reference=cls.refdata_df,
            comparison_function=cls.diff_compare,
            region_agg='mean',
            time_agg=lambda s: s.abs().max(),
            broadcast_dims=('model',)
        )
        cls.ratio_criterion_mixed_units = TimeseriesRefCriterion(
            criterion_name='test_ratio_criterion_mixed_units',
            reference=cls.refdata_df,
            comparison_function=cls.ratio_compare,
            region_agg='mean',
            time_agg=lambda s: s.max(),
            broadcast_dims=('model',)
        )
    ###END def TestTimeseriesRefCriterionComparisons.setUpClass

    def test_diff_comparisons(self):
        pd.testing.assert_series_equal(
            self.diff_df._data,
            self.diff_criterion_mixed_units.compare(self.vettingdata_df),
            check_exact=False,
            atol=1e-12,
            rtol=1e-12,
        )
    ###END def test_diff_comparisons

    def test_ratio_comparisons(self):
        pd.testing.assert_series_equal(
            self.ratio_df._data,
            self.ratio_criterion_mixed_units.compare(self.vettingdata_df),
            check_exact=False,
            atol=1e-12,
            rtol=1e-12,
        )
    ###END def test_ratio_comparisons

###END class TestTimeseriesRefCriterionComparisons
